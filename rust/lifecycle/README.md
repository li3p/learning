
https://time.geekbang.org/column/article/415098

函数调用要求
- 栈上数据大小可知，以便能够在栈上分配栈帧空间
- 函数调用结束后，栈帧空间可以被立即回收，而且速度极快
- 对于动态的数据，大小未知且可变，则只能在堆上分配，速度相差极大

而堆上的数据应该都是跟栈上的一个指针绑定的，指针是定长的，而堆上的数据不是。
在堆上分配的值有可能被多个栈上的指针所指向，从而导致很多问题：
- 野指针 - 二次释放 - 指针悬垂

RUST的就是通过单一所有权来限制任意引用的行为消灭了可以任意引用的这种可能性，通过所有权三规则解决了谁真正拥有数据的生杀大权问题，让堆上数据的多重引用不复存在，这是它最大的优势：

- 一个值只能被一个变量所拥有，这个变量被称为所有者
（Each value in Rust has a variable that’s called its owner）。
- 一个值同一时刻只能有一个所有者（There can only be one owner at a time），也就是说不能有两个变量拥有相同的值。所以对应刚才说的变量赋值、参数传递、函数返回等行为，旧的所有者会把值的所有权转移给新的所有者，以便保证单一所有者的约束。
- 当所有者离开作用域，其拥有的值被丢弃（When the owner goes out of scope, the value will be dropped），内存得到释放。

但是，这也会让代码变复杂，尤其是一些只存储在栈上的简单数据，如果要避免所有权转移之后不能访问的情况，我们就需要手动复制，会非常麻烦，效率也不高。

解决方案有两种：
- Copy 语义：值会按位 copy 
    - 符合 Copy 语义的类型
    - 在赋值和传参时，
- 借用

所以为了保证内存安全，Rust 对可变引用的使用也做了严格的约束：
- 在一个作用域内，仅允许一个活跃的可变引用。所谓活跃，就是真正被使用来修改数据的可变引用，如果只是定义了，却没有使用或者当作只读引用使用，不算活跃。
- 在一个作用域内，活跃的可变引用（写）和只读引用（读）是互斥的，不能同时存在。